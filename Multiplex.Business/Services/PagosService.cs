using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Multiplex.Business.DTOs;
using Multiplex.Business.Enums;
using Multiplex.Business.Interfaces;
using Multiplex.Domain.Contexts.AutoGenerated;
using Multiplex.Domain.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Multiplex.Business.Services
{
    public class PagosService : IPagosService
    {
        private readonly MultiplexContext context;
        private readonly ILogger<PagosService> logger;
        private readonly IEmailSender emailSender;
        private readonly IUsuariosService usuariosService;

        public PagosService(MultiplexContext context, ILogger<PagosService> logger, IEmailSender emailSender, IUsuariosService usuariosService)
        {
            this.context = context;
            this.logger = logger;
            this.emailSender = emailSender;
            this.usuariosService = usuariosService;
        }
        public async Task<int> AddPagoAsync(PagoDTO pago)
        {
            // Obtener el usuario correspondiente
            var usuario = await context.Usuarios.FindAsync(pago.IdUsuario);

            if (usuario == null)
            {
                throw new InvalidOperationException($"Usuario con ID {pago.IdUsuario} no encontrado.");
            }

            //mappera el pagoDto a un pago
            Pagos newPago = new Pagos();
            newPago.Total = pago.Total;
            newPago.FechaPago = pago.FechaPago;
            newPago.IsPagado = pago.IsPagado;

            //guardar el pago y obtener el ID
            var pagoId = await context.Pagos.AddAsync(newPago);
            await context.SaveChangesAsync();

            UsuariosPagos usuariosPagos = new UsuariosPagos();
            usuariosPagos.IdUsr = pago.IdUsuario;
            usuariosPagos.IdPago = pagoId.Entity.IdPago;

            // Agregar el pago al usuario
            context.UsuarioPagos.Add(usuariosPagos);
            await context.SaveChangesAsync();

            return pagoId.Entity.IdPago;
        }

        public async Task<bool> UpdatePagoAsync(int id, PagoDTO pago)
        {
            try
            {
                var pagoToUpdate = await context.Pagos.FindAsync(id);

                if (pagoToUpdate == null)
                {
                    throw new InvalidOperationException($"Pago con ID {id} no encontrado.");
                }

                // Recargar la entidad desde la base de datos
                context.Entry(pagoToUpdate).Reload();

                // Verificar si la entidad todavía existe después de recargar
                if (pagoToUpdate == null)
                {
                    throw new InvalidOperationException($"Pago con ID {id} no encontrado después de recargar.");
                }

                // Actualizar la entidad
                pagoToUpdate.Total = pago.Total;
                pagoToUpdate.IsPagado = pago.IsPagado;
                pagoToUpdate.FechaPago = pago.FechaPago;

                // Configurar el estado de la entidad existente como modificado
                context.Entry(pagoToUpdate).State = EntityState.Modified;

                // Guardar cambios
                await context.SaveChangesAsync();

                return true;
            }
            catch (Exception e)
            {
                logger.LogError(e, $"Error al actualizar el pago con ID {id}.");
                return false;
            }
        }

        public async Task<bool> NotificarAbonadosConPagosPendientes()
        {
            try 
            {
                // Obtener los abonados con pagos pendientes
                var abonadosConPagosPendientes = await context.Usuarios
                 .Where(u => u.IdTcNavigation.DescripcionTc == TiposCuentasEnum.ABONADO)
                 .Where(u => u.UsuariosPagos.Any(up => up.Pago.IsPagado == false))
                 .Include(u => u.UsuariosPagos)
                     .ThenInclude(up => up.Pago)
                 .ToListAsync();

                foreach (var abonado in abonadosConPagosPendientes)
                {
                    // Filtrar solo los pagos pendientes
                    var pagosPendientes = abonado.UsuariosPagos
                        .Where(up => !up.Pago.IsPagado)
                        .Select(up => new
                        {
                            PagoId = up.Pago.IdPago,
                            FechaPago = up.Pago.FechaPago,
                            Total = up.Pago.Total
                        })
                        .ToList();

                    foreach (var pagoPendiente in pagosPendientes)
                    {
                        // Verificar si la deuda está vencida (último día del mes)
                        var ultimoDiaDelMes = new DateTime(DateTime.Today.Year, DateTime.Today.Month, DateTime.DaysInMonth(DateTime.Today.Year, DateTime.Today.Month));
                        if (pagoPendiente.FechaPago < ultimoDiaDelMes)
                        {
                            // Envía un correo electrónico al abonado informándole que debe realizar un pago.
                            string mensaje = $"Estimado {abonado.ApellidoUsr}, {abonado.NombreUsr}: \n\nSu servicio de suscripción está pendiente de pago y ha vencido. Por favor, realice el pago para evitar la suspensión del servicio.";

                            emailSender.SendEmail(abonado.CorreoUsr, "Recordatorio de Pago Vencido", mensaje);
                        }
                    }

                    //si tiene mas de una deuda suspender el servicio 
                    if (pagosPendientes.Count > 1) 
                    {
                        //suspender el servicio
                        await usuariosService.UpdateAbonadoStatus(abonado.IdUsr, EstadosCuentasEnum.SUSPENDIDO);
                    }

                }

                return true;
            }
            catch (Exception e)
            {
                logger.LogError(e, "No se pudo notificar al Abonado");
                return false;
            }
        }
    }
}
